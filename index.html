<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KITTWeb - AI Vehicle Control Interface</title>
    <style>
        /* Reset and base styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a1a 100%);
            color: #ffffff;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid #333;
            padding: 15px 10px;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header-content {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .logo {
            font-size: 1.8em;
            font-weight: bold;
            background: linear-gradient(135deg, #ff0000 0%, #ff6600 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
        }

        .model-selector {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        .model-selector label {
            font-size: 0.9em;
        }

        .model-selector select, .model-selector input {
            background: #222;
            border: 1px solid #444;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.9em;
            cursor: pointer;
        }

        .model-selector button {
            padding: 6px 12px;
            background: #444;
            border: 1px solid #666;
            color: white;
            border-radius: 5px;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .model-selector button:hover {
            background: #555;
            border-color: #777;
        }

        .context-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-left: 10px;
            padding-left: 10px;
            border-left: 1px solid #444;
        }

        .context-controls input {
            width: 60px;
        }

        /* API Configuration Modal */
        .config-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1001;
            overflow-y: auto;
            padding: 20px;
        }

        .config-modal.active {
            display: block;
        }

        .config-content {
            max-width: 600px;
            margin: 0 auto;
            background: #1a1a1a;
            padding: 30px;
            border-radius: 15px;
            border: 1px solid #444;
        }

        .config-content h2 {
            color: #ff6600;
            margin-bottom: 20px;
        }

        .config-group {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border: 1px solid #333;
        }

        .config-group h3 {
            color: #00ff88;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .config-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
            color: #ccc;
        }

        .config-group input {
            width: 100%;
            padding: 10px;
            background: #222;
            border: 1px solid #444;
            border-radius: 5px;
            color: white;
            font-family: monospace;
            font-size: 0.9em;
        }

        .config-group input:focus {
            outline: none;
            border-color: #ff6600;
        }

        .config-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }

        .config-buttons button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .config-save {
            background: linear-gradient(135deg, #00ff88 0%, #00cc66 100%);
            color: #000;
        }

        .config-cancel {
            background: #444;
            color: white;
        }

        .config-buttons button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .config-button {
            padding: 8px 16px;
            background: linear-gradient(135deg, #ff6600 0%, #ff9900 100%);
            border: none;
            border-radius: 5px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .config-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 102, 0, 0.3);
        }

        .main-container {
            flex: 1;
            width: 100%;
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            padding: 0 10px;
        }

        /* ==== Fixed, Scrollable Chat Area (50% of viewport) ==== */
        .chat-container {
            background: rgba(20, 20, 20, 0.8);
            border-radius: 15px;
            padding: 15px;
            height: 50vh;
            overflow-y: scroll;
            margin-bottom: 15px;
            border: 1px solid #333;
            position: relative;
        }

        .chat-message {
            margin-bottom: 15px;
            padding: 12px;
            border-radius: 12px;
            animation: slideIn 0.3s ease;
            max-width: 90%;
            word-wrap: break-word;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(8px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .user-message {
            background: linear-gradient(135deg, #0066ff 0%, #0099ff 100%);
            margin-left: auto;
            text-align: right;
        }

        .assistant-message {
            background: linear-gradient(135deg, #333 0%, #444 100%);
            margin-right: auto;
        }

        .assistant-message.knowledge {
            background: linear-gradient(135deg, #4a4a4a 0%, #666 100%);
            border-left: 4px solid #00ff88;
            margin-right: auto;
        }

        .system-message {
            background: linear-gradient(135deg, #ff6600 0%, #ff9900 100%);
            text-align: center;
            font-weight: bold;
            margin: 0 auto 15px;
            max-width: 100%;
        }

        .warning-message {
            background: linear-gradient(135deg, #ff4444 0%, #ff6666 100%);
            text-align: center;
            font-weight: bold;
            margin: 0 auto 15px;
            max-width: 100%;
            border: 2px solid #ff0000;
        }

        .context-indicator {
            background: linear-gradient(135deg, #444 0%, #555 100%);
            text-align: center;
            font-style: italic;
            font-size: 0.8em;
            margin: 0 auto 10px;
            max-width: 80%;
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid #666;
        }

        /* ==== Input Area ==== */
        .input-container {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .input-wrapper {
            flex: 1;
            position: relative;
        }

        .text-input {
            width: 100%;
            padding: 14px 45px 14px 18px;
            background: rgba(30, 30, 30, 0.8);
            border: 1px solid #444;
            border-radius: 30px;
            color: white;
            font-size: 1em;
            transition: all 0.3s ease;
        }

        .text-input:focus {
            outline: none;
            border-color: #ff6600;
            box-shadow: 0 0 15px rgba(255, 102, 0, 0.3);
        }

        .text-input:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* ==== Voice Button with Glowing States ==== */
        .voice-button {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ff0000 0%, #ff6600 100%);
            border: none;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            font-size: 1.1em;
        }

        .voice-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Recording (taking input): pulsating red glow */
        .voice-button.recording {
            animation: pulse-red 1.2s infinite;
            background: linear-gradient(135deg, #ff0000 0%, #ff0066 100%);
            box-shadow: 0 0 8px rgba(255, 0, 0, 0.8);
        }

        /* Playing (text-to-speech active): pulsating green glow */
        .voice-button.playing {
            animation: pulse-green 1.2s infinite;
            background: linear-gradient(135deg, #00ff88 0%, #00cc66 100%);
            box-shadow: 0 0 8px rgba(0, 255, 0, 0.8);
        }

        @keyframes pulse-red {
            0%   { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0.7); }
            50%  { box-shadow: 0 0 10px 4px rgba(255, 0, 0, 0.7); }
            100% { box-shadow: 0 0 0 0 rgba(255, 0, 0, 0); }
        }

        @keyframes pulse-green {
            0%   { box-shadow: 0 0 0 0 rgba(0, 255, 0, 0.7); }
            50%  { box-shadow: 0 0 10px 4px rgba(0, 255, 0, 0.7); }
            100% { box-shadow: 0 0 0 0 rgba(0, 255, 0, 0); }
        }

        .send-button {
            padding: 12px 24px;
            background: linear-gradient(135deg, #00ff88 0%, #00cc66 100%);
            border: none;
            border-radius: 30px;
            color: #000;
            font-weight: bold;
            font-size: 1em;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .send-button:hover:not(:disabled) {
            transform: scale(1.03);
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.4);
        }

        .send-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* ==== Logs Area ==== */
        .logs-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 10px;
        }

        .log-panel {
            background: rgba(20, 20, 20, 0.8);
            border-radius: 12px;
            padding: 12px;
            border: 1px solid #333;
            max-height: 200px;
            overflow-y: auto;
        }

        .log-panel h3 {
            margin-bottom: 10px;
            color: #ff6600;
            font-size: 1em;
        }

        .log-entry {
            font-family: 'Courier New', monospace;
            font-size: 11px;
            padding: 6px;
            margin-bottom: 4px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            border-left: 3px solid #ff6600;
            word-wrap: break-word;
            cursor: pointer;
        }

        .log-entry.knowledge {
            border-left-color: #00ff88;
        }

        /* ==== Status Indicator ==== */
        .status-indicator {
            position: fixed;
            bottom: 15px;
            right: 15px;
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 18px;
            display: flex;
            align-items: center;
            gap: 8px;
            backdrop-filter: blur(10px);
            font-size: 0.9em;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #00ff00;
            animation: blink 2s infinite;
        }

        .status-dot.error {
            background: #ff0000;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* ==== Connection Status Badge ==== */
        .connection-status {
            position: fixed;
            top: 70px;
            right: 20px;
            padding: 8px 16px;
            background: rgba(0, 0, 0, 0.8);
            border-radius: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
            backdrop-filter: blur(10px);
            font-size: 0.85em;
            border: 1px solid #333;
            z-index: 99;
        }

        .connection-status.connected {
            border-color: #00ff88;
            color: #00ff88;
        }

        .connection-status.disconnected {
            border-color: #ff4444;
            color: #ff4444;
        }

        /* ==== Full Prompt Modal ==== */
        .prompt-display {
            display: none;
            background: rgba(0, 0, 0, 0.9);
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 1000;
            overflow-y: auto;
            padding: 30px;
        }

        .prompt-content {
            max-width: 700px;
            margin: 0 auto;
            background: #1a1a1a;
            padding: 25px;
            border-radius: 12px;
            border: 1px solid #444;
        }

        .prompt-content h3 {
            color: #ff6600;
            margin-bottom: 15px;
        }

        .prompt-content pre {
            background: #000;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-size: 0.9em;
        }

        .close-prompt, .close-output {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #ff6600;
            border: none;
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
        }

        /* ==== Full Output Modal ==== */
        .output-display {
            display: none;
            background: rgba(0, 0, 0, 0.9);
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 1000;
            overflow-y: auto;
            padding: 30px;
        }

        .output-content {
            max-width: 700px;
            margin: 0 auto;
            background: #1a1a1a;
            padding: 25px;
            border-radius: 12px;
            border: 1px solid #444;
        }

        .output-content h3 {
            color: #00ff88;
            margin-bottom: 15px;
        }

        .output-content pre {
            background: #000;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-size: 0.9em;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        ::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #666;
        }

        /* ==== Responsive Adjustments (<= 600px) ==== */
        @media (max-width: 768px) {
            .header-content {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }

            .logo {
                font-size: 1.6em;
            }

            .model-selector {
                flex-wrap: wrap;
                width: 100%;
            }

            .context-controls {
                margin-left: 0;
                padding-left: 0;
                border-left: none;
                border-top: 1px solid #444;
                padding-top: 8px;
                width: 100%;
            }

            .chat-container {
                padding: 12px;
                margin-bottom: 12px;
                height: 50vh;
            }

            .chat-message {
                padding: 10px;
                font-size: 0.95em;
                max-width: 100%;
            }

            .input-container {
                flex-direction: column;
                gap: 8px;
            }

            .text-input {
                padding: 12px 45px 12px 15px;
                font-size: 0.95em;
            }

            .voice-button {
                width: 34px;
                height: 34px;
                font-size: 1em;
            }

            .send-button {
                padding: 10px 20px;
                font-size: 0.95em;
            }

            .logs-container {
                display: flex;
                flex-direction: column;
                gap: 10px;
            }

            .log-panel {
                max-height: 150px;
                padding: 10px;
            }

            .status-indicator {
                bottom: 10px;
                right: 10px;
                padding: 6px 12px;
                font-size: 0.85em;
            }

            .connection-status {
                top: auto;
                bottom: 60px;
                right: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-content">
            <div class="logo">üöó KITTWeb v6</div>
            <div class="model-selector">
                <label for="model-select">LLM Model:</label>
                <select id="model-select">
                    <option value="openai">ChatGPT 4o-mini</option>
                    <option value="claude">Claude Sonnet 4</option>
                    <option value="local">Local LLM (localhost:1234)</option>
                </select>
                <button class="config-button" onclick="showConfigModal()">‚öôÔ∏è Configure API Keys</button>
                <div class="context-controls">
                    <label for="context-timeout">Context timeout (mins):</label>
                    <input type="number" id="context-timeout" value="5" min="1" max="60">
                    <button onclick="clearContext()">Clear Context</button>
                </div>
            </div>
        </div>
    </div>

    <div class="connection-status disconnected" id="vehiclesim-status">
        <span>üöó VehicleSim: <span id="vehiclesim-status-text">Disconnected</span></span>
    </div>

    <div class="main-container">
        <!-- Fixed, scrollable chat area -->
        <div class="chat-container" id="chat-container">
            <div class="chat-message system-message">
                Welcome to KITTWeb v6! I'm your AI vehicle assistant with persistent conversation memory.
            </div>
        </div>

        <!-- Input area below the fixed chat -->
        <div class="input-container">
            <div class="input-wrapper">
                <input 
                    type="text" 
                    class="text-input" 
                    id="user-input" 
                    placeholder="Configure API keys first, then ask me anything..."
                    onkeypress="handleKeyPress(event)"
                    disabled
                >
                <button class="voice-button" id="voice-button" onclick="voiceButtonClicked()" disabled>
                    üé§
                </button>
            </div>
            <button class="send-button" id="send-button" onclick="sendMessage()" disabled>Send</button>
        </div>

        <!-- Logs area with clickable entries -->
        <div class="logs-container">
            <div class="log-panel">
                <h3>üìù Prompt Log</h3>
                <div id="prompt-log"></div>
            </div>
            <div class="log-panel">
                <h3>üîß LLM Output Log</h3>
                <div id="output-log"></div>
            </div>
        </div>
    </div>

    <!-- Status indicator -->
    <div class="status-indicator">
        <div class="status-dot" id="status-dot"></div>
        <span id="status-text">Ready</span>
    </div>

    <!-- API Configuration Modal -->
    <div class="config-modal" id="config-modal">
        <div class="config-content">
            <h2>‚öôÔ∏è API Configuration</h2>
            
            <div class="config-group">
                <h3>OpenAI Configuration</h3>
                <label for="openai-key">API Key:</label>
                <input type="password" id="openai-key" placeholder="sk-...">
                <label for="openai-model" style="margin-top: 10px;">Model:</label>
                <input type="text" id="openai-model" value="gpt-4o-mini">
            </div>

            <div class="config-group">
                <h3>Claude (Anthropic) Configuration</h3>
                <label for="claude-key">API Key:</label>
                <input type="password" id="claude-key" placeholder="sk-ant-api03-...">
                <label for="claude-model" style="margin-top: 10px;">Model:</label>
                <input type="text" id="claude-model" value="claude-3-sonnet-20240229">
            </div>

            <div class="config-group">
                <h3>Local LLM Configuration</h3>
                <label for="local-endpoint">Endpoint URL:</label>
                <input type="text" id="local-endpoint" value="http://localhost:1234/v1/chat/completions">
                <label for="local-model" style="margin-top: 10px;">Model Name:</label>
                <input type="text" id="local-model" placeholder="e.g., qwen3-4b">
            </div>

            <div class="config-buttons">
                <button class="config-cancel" onclick="hideConfigModal()">Cancel</button>
                <button class="config-save" onclick="saveConfig()">Save Configuration</button>
            </div>
        </div>
    </div>

    <!-- Full-prompt modal -->
    <div class="prompt-display" id="prompt-display">
        <button class="close-prompt" onclick="closePromptDisplay()">Close</button>
        <div class="prompt-content">
            <h3>Full Prompt</h3>
            <pre id="full-prompt-content"></pre>
        </div>
    </div>

    <!-- Full-output modal -->
    <div class="output-display" id="output-display">
        <button class="close-output" onclick="closeOutputDisplay()">Close</button>
        <div class="output-content">
            <h3>Full Output</h3>
            <pre id="full-output-content"></pre>
        </div>
    </div>

    <script>
        // Configuration storage keys
        const CONFIG_STORAGE_KEY = 'kittweb_api_config';
        const CONVERSATION_STORAGE_KEY = 'kittweb_conversation_history';

        // Configuration object (will be loaded from localStorage)
        let config = {
            openai: {
                apiKey: '',
                model: 'gpt-4o-mini',
                endpoint: 'https://api.openai.com/v1/chat/completions'
            },
            claude: {
                apiKey: '',
                model: 'claude-3-sonnet-20240229',
                endpoint: 'https://api.anthropic.com/v1/messages'
            },
            local: {
                endpoint: 'http://localhost:1234/v1/chat/completions',
                model: ''
            }
        };

        // VehicleSim URL
        const VEHICLESIM_URL = 'https://wkcwei.github.io/vehiclesim/';

        // Global state variables
        let currentModel = 'openai';
        let isRecording = false;
        let recognition = null;
        let vehicleSimWindow = null;
        let vehicleSimConnected = false;
        let apiConfigured = false;

        // Persistent conversation memory
        let conversationHistory = [];
        let lastMessageTime = null;
        let contextTimeoutMinutes = 5;

        // Load configuration on startup
        function loadConfig() {
            try {
                const saved = localStorage.getItem(CONFIG_STORAGE_KEY);
                if (saved) {
                    const savedConfig = JSON.parse(saved);
                    // Merge with default config to ensure all fields exist
                    config = { ...config, ...savedConfig };
                    
                    // Populate the config modal with saved values
                    document.getElementById('openai-key').value = config.openai.apiKey || '';
                    document.getElementById('openai-model').value = config.openai.model || 'gpt-4o-mini';
                    document.getElementById('claude-key').value = config.claude.apiKey || '';
                    document.getElementById('claude-model').value = config.claude.model || 'claude-3-sonnet-20240229';
                    document.getElementById('local-endpoint').value = config.local.endpoint || 'http://localhost:1234/v1/chat/completions';
                    document.getElementById('local-model').value = config.local.model || '';
                    
                    // Check if at least one API is configured
                    checkApiConfiguration();
                    
                    return true;
                }
            } catch (error) {
                console.error('Failed to load configuration:', error);
            }
            return false;
        }

        // Save configuration
        function saveConfig() {
            config.openai.apiKey = document.getElementById('openai-key').value;
            config.openai.model = document.getElementById('openai-model').value;
            config.claude.apiKey = document.getElementById('claude-key').value;
            config.claude.model = document.getElementById('claude-model').value;
            config.local.endpoint = document.getElementById('local-endpoint').value;
            config.local.model = document.getElementById('local-model').value;
            
            try {
                localStorage.setItem(CONFIG_STORAGE_KEY, JSON.stringify(config));
                hideConfigModal();
                checkApiConfiguration();
                addSystemMessage('‚úÖ API configuration saved successfully!');
            } catch (error) {
                console.error('Failed to save configuration:', error);
                showError('Failed to save configuration');
            }
        }

        // Check if APIs are configured
        function checkApiConfiguration() {
            const openaiConfigured = config.openai.apiKey && config.openai.apiKey.length > 0;
            const claudeConfigured = config.claude.apiKey && config.claude.apiKey.length > 0;
            const localConfigured = config.local.model && config.local.model.length > 0;
            
            apiConfigured = openaiConfigured || claudeConfigured || localConfigured;
            
            // Enable/disable input based on configuration
            const userInput = document.getElementById('user-input');
            const sendButton = document.getElementById('send-button');
            const voiceButton = document.getElementById('voice-button');
            
            if (apiConfigured) {
                userInput.disabled = false;
                sendButton.disabled = false;
                voiceButton.disabled = false;
                userInput.placeholder = "Ask me anything... (Vehicle: 'Start car' | General: 'What's quantum physics?')";
                
                // Update model selector to show only configured models
                const modelSelect = document.getElementById('model-select');
                const currentValue = modelSelect.value;
                modelSelect.innerHTML = '';
                
                if (openaiConfigured) {
                    modelSelect.innerHTML += '<option value="openai">ChatGPT 4o-mini</option>';
                }
                if (claudeConfigured) {
                    modelSelect.innerHTML += '<option value="claude">Claude Sonnet</option>';
                }
                if (localConfigured) {
                    modelSelect.innerHTML += `<option value="local">Local LLM (${config.local.model})</option>`;
                }
                
                // Try to restore previous selection or default to first available
                if (modelSelect.querySelector(`option[value="${currentValue}"]`)) {
                    modelSelect.value = currentValue;
                } else if (modelSelect.options.length > 0) {
                    modelSelect.value = modelSelect.options[0].value;
                    currentModel = modelSelect.value;
                }
            } else {
                userInput.disabled = true;
                sendButton.disabled = true;
                voiceButton.disabled = true;
                userInput.placeholder = "Please configure API keys first...";
                
                // Show configuration needed message
                if (!document.querySelector('.warning-message')) {
                    const chatContainer = document.getElementById('chat-container');
                    const warningDiv = document.createElement('div');
                    warningDiv.className = 'chat-message warning-message';
                    warningDiv.textContent = '‚ö†Ô∏è No API keys configured! Click the "Configure API Keys" button to get started.';
                    chatContainer.appendChild(warningDiv);
                }
            }
        }

        // Show/hide configuration modal
        function showConfigModal() {
            document.getElementById('config-modal').classList.add('active');
        }

        function hideConfigModal() {
            document.getElementById('config-modal').classList.remove('active');
        }

        // Conversation memory management
        class PersistentConversationMemory {
            static save() {
                try {
                    const memoryData = {
                        history: conversationHistory,
                        lastMessageTime: lastMessageTime,
                        contextTimeoutMinutes: contextTimeoutMinutes,
                        timestamp: Date.now()
                    };
                    localStorage.setItem(CONVERSATION_STORAGE_KEY, JSON.stringify(memoryData));
                    return true;
                } catch (error) {
                    console.error('Failed to save conversation memory:', error);
                    return false;
                }
            }

            static load() {
                try {
                    const stored = localStorage.getItem(CONVERSATION_STORAGE_KEY);
                    if (!stored) return false;

                    const memoryData = JSON.parse(stored);
                    conversationHistory = memoryData.history || [];
                    lastMessageTime = memoryData.lastMessageTime;
                    contextTimeoutMinutes = memoryData.contextTimeoutMinutes || 5;
                    
                    document.getElementById('context-timeout').value = contextTimeoutMinutes;
                    
                    return true;
                } catch (error) {
                    console.error('Failed to load conversation memory:', error);
                    return false;
                }
            }

            static clear() {
                try {
                    localStorage.removeItem(CONVERSATION_STORAGE_KEY);
                    conversationHistory = [];
                    lastMessageTime = null;
                    return true;
                } catch (error) {
                    console.error('Failed to clear conversation memory:', error);
                    return false;
                }
            }

            static getStorageInfo() {
                try {
                    const stored = localStorage.getItem(CONVERSATION_STORAGE_KEY);
                    return {
                        exists: !!stored,
                        size: stored ? stored.length : 0,
                        messageCount: conversationHistory.length,
                        lastActivity: lastMessageTime ? new Date(lastMessageTime).toLocaleString() : 'Never'
                    };
                } catch (error) {
                    return { exists: false, error: error.message };
                }
            }
        }

        // Update VehicleSim connection status
        function updateVehicleSimStatus(connected) {
            vehicleSimConnected = connected;
            const statusElement = document.getElementById('vehiclesim-status');
            const statusText = document.getElementById('vehiclesim-status-text');
            
            if (connected) {
                statusElement.classList.remove('disconnected');
                statusElement.classList.add('connected');
                statusText.textContent = 'Connected';
            } else {
                statusElement.classList.remove('connected');
                statusElement.classList.add('disconnected');
                statusText.textContent = 'Disconnected';
            }
        }

        // Initialize speech recognition if supported
        if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            recognition.continuous = false;
            recognition.interimResults = false;
            recognition.lang = 'en-US';

            recognition.onresult = function(event) {
                const transcript = event.results[0][0].transcript;
                document.getElementById('user-input').value = transcript;
                stopRecording();
                sendMessage();
            };

            recognition.onerror = function(event) {
                console.error('Speech recognition error:', event.error);
                stopRecording();
                showError('Speech recognition error: ' + event.error);
            };

            recognition.onend = function() {
                stopRecording();
            };
        }

        // Speech synthesis function
        function speak(text) {
            if ('speechSynthesis' in window) {
                if (speechSynthesis.speaking) {
                    speechSynthesis.cancel();
                }

                const utterance = new SpeechSynthesisUtterance(text);
                utterance.rate = 1.0;
                utterance.pitch = 0.8;
                utterance.volume = 1.0;

                const voices = speechSynthesis.getVoices();
                const roboticVoice = voices.find(voice => 
                    voice.name.toLowerCase().includes('female') ||
                    voice.name.toLowerCase().includes('woman') ||
                    voice.name.toLowerCase().includes('girl') ||
                    voice.name.toLowerCase().includes('google') ||
                    voice.name.toLowerCase().includes('microsoft')
                );
                if (roboticVoice) {
                    utterance.voice = roboticVoice;
                }

                utterance.onstart = () => {
                    setVoiceButtonState();
                };
                utterance.onend = () => {
                    setVoiceButtonState();
                };
                utterance.onerror = () => {
                    setVoiceButtonState();
                };

                speechSynthesis.speak(utterance);
                setVoiceButtonState();
            }
        }

        // Context management functions
        function checkContextTimeout() {
            const now = Date.now();
            const timeoutMs = contextTimeoutMinutes * 60 * 1000;
            
            if (lastMessageTime && (now - lastMessageTime) > timeoutMs) {
                clearContext();
                addContextIndicator(`üîÑ Context reset after ${contextTimeoutMinutes} minutes of inactivity`);
                return true;
            }
            return false;
        }

        function clearContext() {
            PersistentConversationMemory.clear();
            addSystemMessage(`üßπ Conversation memory cleared (${conversationHistory.length} messages removed)`);
        }

        function addToConversationHistory(role, content, isVehicleQuery = false) {
            conversationHistory.push({
                role,
                content,
                timestamp: Date.now(),
                isVehicleQuery
            });
            lastMessageTime = Date.now();
            
            if (conversationHistory.length > 20) {
                conversationHistory = conversationHistory.slice(-20);
            }

            PersistentConversationMemory.save();
        }

        function buildContextualPrompt(currentInput, systemPrompt, isVehicleQuery) {
            let contextualPrompt = systemPrompt;
            
            if (conversationHistory.length > 0) {
                contextualPrompt += "\n\n=== CONVERSATION HISTORY ===\n";
                conversationHistory.slice(-10).forEach(msg => {
                    const timeAgo = Math.round((Date.now() - msg.timestamp) / (1000 * 60));
                    const queryType = msg.isVehicleQuery ? '[VEHICLE]' : '[GENERAL]';
                    contextualPrompt += `${queryType} ${msg.role.toUpperCase()} (${timeAgo}m ago): ${msg.content}\n`;
                });
                contextualPrompt += "=== END HISTORY ===\n\n";
                contextualPrompt += "Based on the conversation history above, respond to the current user message. ";
                contextualPrompt += "If the user is responding to a previous question or continuing a topic, use that context. ";
                contextualPrompt += "If they're giving a simple answer (like 'yes', 'no', '23 degrees', 'office'), interpret it in context.\n\n";
            }
            
            return contextualPrompt;
        }

        function addContextIndicator(message) {
            const chatContainer = document.getElementById('chat-container');
            const indicatorDiv = document.createElement('div');
            indicatorDiv.className = 'context-indicator';
            indicatorDiv.textContent = message;
            chatContainer.appendChild(indicatorDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        // Enhanced system prompts
        const vehicleSystemPrompt = `You are KITT, an advanced AI vehicle control system. You help users control their vehicle through natural language commands.

CRITICAL INSTRUCTION: You MUST ALWAYS generate function calls for ANY vehicle-related request, including status inquiries. NEVER provide status information without making the actual API call to retrieve real data.

Your capabilities include:
- Starting/stopping the engine
- Locking/unlocking doors
- Opening/closing windows
- Climate control (temperature, AC)
- Entertainment system (music, radio)
- Navigation
- Seat adjustments and comfort features
- Status inquiries for all vehicle systems

You understand both direct commands and abstract requests. For abstract requests like "It's hot", you should infer the user wants to cool down the vehicle and take appropriate actions.
When referring to temperature, always use Celsius.

IMPORTANT: You have persistent conversation memory that survives browser sessions. Use the conversation history to understand context:
- If a user gives a short answer like "yes", "25 degrees", "office", look at recent conversation to understand what they're responding to
- If you previously asked a clarifying question, interpret their response in that context
- Maintain continuity in multi-turn conversations about vehicle settings or status
- Reference previous commands and settings when relevant

When responding to ANY VEHICLE-RELATED request (commands OR status inquiries), you MUST:
1. Interpret the user's intent
2. ALWAYS generate appropriate function calls in the following JSON format:
{
  "functions": [
    {
      "endpoint": "/api/vehicle/[domain]/[action]",
      "method": "GET" or "POST",
      "body": { /* parameters if needed for POST */ }
    }
  ],
  "response": "Natural language response to the user",
  "isVehicleCommand": true
}

CRITICAL: For status inquiries, you MUST generate a function call with method: "GET". Do NOT provide status information without making the API call.

Available endpoints:
CONTROL COMMANDS (method: "POST"):
- /api/vehicle/engine/start
- /api/vehicle/engine/stop  
- /api/vehicle/doors/lock
- /api/vehicle/doors/unlock
- /api/vehicle/windows/open
- /api/vehicle/windows/close
- /api/vehicle/climate/temperature (body: { temperature: number })
- /api/vehicle/climate/ac/toggle
- /api/vehicle/entertainment/play (body: { source: string, track: string, volume: number })
- /api/vehicle/entertainment/stop
- /api/vehicle/navigation/set (body: { destination: string, eta: string })
- /api/vehicle/navigation/clear
- /api/vehicle/comfort/seat/adjust (body: { position: number })
- /api/vehicle/comfort/seat/heating
- /api/vehicle/lighting/headlights/toggle
- /api/vehicle/security/arm
- /api/vehicle/security/disarm
- /api/vehicle/chassis/esc/toggle

STATUS INQUIRIES (method: "GET", no body needed):
- /api/vehicle/status (overall vehicle status)
- /api/vehicle/engine/status (engine RPM, temperature, power mode)
- /api/vehicle/doors/status (all door states, security status)
- /api/vehicle/windows/status (window positions, overall status)
- /api/vehicle/climate/status (temperature, AC, fan, air quality)
- /api/vehicle/entertainment/status (audio, volume, source, Bluetooth)
- /api/vehicle/navigation/status (GPS, destination, route, traffic)
- /api/vehicle/comfort/status (seats, heating, steering, mirrors)
- /api/vehicle/lighting/status (headlights, taillights, signals)
- /api/vehicle/security/status (immobilizer, alarm, keyless entry)
- /api/vehicle/chassis/status (ABS, ESC, traction, suspension)
- /api/vehicle/sensors/status (tire pressure, proximity sensors)
- /api/vehicle/sensors/tire-pressure (detailed tire pressure readings)

Examples of CORRECT status inquiry responses:
User: "What's the climate status?"
Response: {
  "functions": [{
    "endpoint": "/api/vehicle/climate/status",
    "method": "GET"
  }],
  "response": "Checking the climate control status for you. This will show the current temperature settings, AC operation, fan speed, and air quality conditions.",
  "isVehicleCommand": true
}

User: "Check the engine"
Response: {
  "functions": [{
    "endpoint": "/api/vehicle/engine/status",
    "method": "GET"
  }],
  "response": "I'll check the engine status for you right away.",
  "isVehicleCommand": true
}

For abstract commands:
- "It's hot" ‚Üí Turn on AC, set cool temperature, maybe open windows
- "Get ready for office" ‚Üí Start engine, set navigation, adjust seat, play music
- "I'm cold" ‚Üí Turn on heating, close windows, turn on seat heating

IMPORTANT: For NON-VEHICLE questions (general knowledge, trivia, explanations, etc.), respond with:
{
  "response": "Your helpful answer to the question",
  "isVehicleCommand": false
}

Remember: ALWAYS generate function calls for vehicle-related requests. NEVER provide vehicle status information without making the actual API call.`;

        const generalSystemPrompt = `You are KITT, an advanced AI assistant. The user has asked you a general knowledge question that is not related to vehicle control. Please provide a helpful, accurate, and informative response. Be conversational and friendly while maintaining accuracy.

IMPORTANT: You have persistent conversation memory that survives browser sessions. Use the conversation history to understand context:
- If a user gives a short answer like "yes", "no", or asks a follow-up question, use the conversation history to understand what they're referring to
- Maintain continuity in multi-turn conversations about any topic
- If they're asking for clarification or more details about a previous response, provide that context

Respond with a JSON format:
{
  "response": "Your helpful answer to the question",
  "isVehicleCommand": false
}`;

        // Vehicle detection function
        function isVehicleRelated(input) {
            const vehicleKeywords = [
                'start', 'stop', 'engine', 'car', 'vehicle', 'drive', 'driving',
                'door', 'lock', 'unlock', 'window', 'open', 'close',
                'temperature', 'hot', 'cold', 'heating', 'cooling', 'ac',
                'music', 'radio', 'entertainment', 'play', 'volume',
                'navigation', 'navigate', 'gps', 'destination', 'route',
                'seat', 'comfort', 'adjust', 'position',
                'status', 'check', 'show me', 'what is', 'how is', 'tell me about',
                'lights', 'headlights', 'taillights', 'turn on', 'turn off',
                'security', 'alarm', 'immobilizer', 'keyless',
                'abs', 'esc', 'traction', 'chassis', 'suspension',
                'tire pressure', 'sensors', 'proximity',
                'bluetooth', 'audio', 'climate control',
                'ready for', 'get ready', 'commute', 'office', 'home',
                "it's hot", "it's cold", "i'm cold", "i'm hot"
            ];
            
            const lower = input.toLowerCase().trim();
            
            if (vehicleKeywords.some(kw => lower.includes(kw))) {
                return true;
            }
            
            const contextualResponses = [
                'yes', 'no', 'okay', 'ok', 'sure', 'please', 'go ahead', 'do it',
                'turn it on', 'turn it off', 'make it', 'set it', 'adjust it',
                'that sounds good', 'sounds good', 'perfect', 'exactly',
                'warmer', 'cooler', 'louder', 'quieter', 'faster', 'slower',
                'higher', 'lower', 'more', 'less'
            ];
            
            if (contextualResponses.some(response => lower === response || lower.includes(response))) {
                const recentVehicleContext = conversationHistory.slice(-3).some(msg => 
                    msg.role === 'assistant' && msg.isVehicleQuery
                );
                
                if (recentVehicleContext) {
                    console.log(`Contextual vehicle response detected: "${input}"`);
                    return true;
                }
            }
            
            if (/\d+/.test(input) && conversationHistory.length > 0) {
                const recentVehicleContext = conversationHistory.slice(-2).some(msg => 
                    msg.isVehicleQuery && (
                        msg.content.includes('temperature') || 
                        msg.content.includes('position') || 
                        msg.content.includes('volume') ||
                        msg.content.includes('speed') ||
                        msg.content.includes('level')
                    )
                );
                
                if (recentVehicleContext) {
                    console.log(`Numeric vehicle response detected: "${input}"`);
                    return true;
                }
            }
            
            return false;
        }

        // Voice functions
        function voiceButtonClicked() {
            if (!apiConfigured) {
                showError('Please configure API keys first');
                return;
            }
            
            if ('speechSynthesis' in window && speechSynthesis.speaking) {
                speechSynthesis.cancel();
                setVoiceButtonState();
                return;
            }
            
            if (!recognition) {
                showError('Speech recognition not supported in your browser');
                return;
            }
            
            if (isRecording) {
                stopRecording();
            } else {
                startRecording();
            }
        }

        function startRecording() {
            isRecording = true;
            setVoiceButtonState();
            recognition.start();
        }

        function stopRecording() {
            isRecording = false;
            if (recognition) {
                recognition.stop();
            }
            setVoiceButtonState();
        }

        function setVoiceButtonState() {
            const btn = document.getElementById('voice-button');
            btn.classList.remove('recording', 'playing');
            if (isRecording) {
                btn.classList.add('recording');
            } else if ('speechSynthesis' in window && speechSynthesis.speaking) {
                btn.classList.add('playing');
            }
        }

        // Handle Enter key
        function handleKeyPress(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        }

        // Main send message function
        async function sendMessage() {
            if (!apiConfigured) {
                showError('Please configure API keys first');
                return;
            }
            
            const inputEl = document.getElementById('user-input');
            const input = inputEl.value.trim();
            if (!input) return;

            checkContextTimeout();
            
            const timeoutInput = document.getElementById('context-timeout');
            contextTimeoutMinutes = parseInt(timeoutInput.value) || 5;

            const isVehicleQuery = isVehicleRelated(input);
            
            console.log(`Input: "${input}" | Detected as: ${isVehicleQuery ? 'VEHICLE' : 'GENERAL'}`);
            
            addChatMessage(input, 'user');
            inputEl.value = '';

            addToConversationHistory('user', input, isVehicleQuery);

            document.getElementById('send-button').disabled = true;

            try {
                const modelType = document.getElementById('model-select').value;

                const result = await processWithLLM(input, modelType, isVehicleQuery);

                let finalResponse = result.response;
                let messageClass = 'assistant';

                addToConversationHistory('assistant', result.response, result.isVehicleCommand);

                if (result.isVehicleCommand && result.functions && result.functions.length) {
                    const commandResults = await executeVehicleCommands(result.functions);
                    
                    console.log('üîç Processing command results:', commandResults);

                    const statusResults = commandResults.filter(r => {
                        console.log('üîé Checking result:', r);
                        return r && r.success && r.data;
                    });
                    const successfulCommands = commandResults.filter(r => r && r.success && r.status);
                    
                    console.log('üìä Status results found:', statusResults.length);
                    console.log('‚úÖ Successful commands found:', successfulCommands.length);
                    
                    if (statusResults.length > 0) {
                        const vehicleData = statusResults[0].data;
                        console.log('üöó Vehicle data to display:', vehicleData);
                        
                        finalResponse += `\n\nüìä **Current Vehicle Status:**`;
                        
                        const requestedEndpoint = result.functions[0]?.endpoint || '';
                        
                        // Status display logic for different endpoints
                        if (requestedEndpoint.includes('/engine/status')) {
                            finalResponse += `\nüöó **Engine Status:**`;
                            finalResponse += `\n   ‚Ä¢ Status: ${vehicleData.status || 'Unknown'}`;
                            if (vehicleData.rpm !== undefined) finalResponse += `\n   ‚Ä¢ RPM: ${vehicleData.rpm}`;
                            if (vehicleData.temperature !== undefined) finalResponse += `\n   ‚Ä¢ Temperature: ${vehicleData.temperature}¬∞C`;
                            if (vehicleData.powerMode) finalResponse += `\n   ‚Ä¢ Power Mode: ${vehicleData.powerMode}`;
                            if (vehicleData.oilPressure !== undefined) finalResponse += `\n   ‚Ä¢ Oil Pressure: ${vehicleData.oilPressure} PSI`;
                            if (vehicleData.coolantLevel !== undefined) finalResponse += `\n   ‚Ä¢ Coolant Level: ${vehicleData.coolantLevel}%`;
                        }
                        else if (requestedEndpoint.includes('/climate/status')) {
                            finalResponse += `\nüå°Ô∏è **Climate Status:**`;
                            const climateData = vehicleData.climate || vehicleData;
                            
                            if (climateData.temperature !== undefined) finalResponse += `\n   ‚Ä¢ Temperature: ${climateData.temperature}¬∞C`;
                            if (climateData.targetTemperature !== undefined) finalResponse += `\n   ‚Ä¢ Target: ${climateData.targetTemperature}¬∞C`;
                            if (climateData.acStatus) finalResponse += `\n   ‚Ä¢ AC: ${climateData.acStatus}`;
                            if (climateData.fanSpeed !== undefined) finalResponse += `\n   ‚Ä¢ Fan Speed: ${climateData.fanSpeed}`;
                            if (climateData.airQuality) finalResponse += `\n   ‚Ä¢ Air Quality: ${climateData.airQuality}`;
                            if (climateData.defrost) finalResponse += `\n   ‚Ä¢ Defrost: ${climateData.defrost}`;
                            if (climateData.recirculation !== undefined) finalResponse += `\n   ‚Ä¢ Recirculation: ${climateData.recirculation}`;
                            if (climateData.autoMode !== undefined) finalResponse += `\n   ‚Ä¢ Auto Mode: ${climateData.autoMode ? 'ON' : 'OFF'}`;
                            if (climateData.comfortable !== undefined) finalResponse += `\n   ‚Ä¢ Comfort Level: ${climateData.comfortable ? 'COMFORTABLE' : 'NEEDS ADJUSTMENT'}`;
                        }
                        // ... (all other endpoint handlers continue in the same pattern)
                    } else {
                        console.warn('‚ö†Ô∏è No status data found in results');
                        
                        if (commandResults.length === 0) {
                            finalResponse += `\n\n‚ùå **Connection Error:** No response from VehicleSim. Please ensure VehicleSim is running and accessible.`;
                        } else {
                            const resultSummary = commandResults.map(r => {
                                if (r.success) {
                                    return r.status || 'Command executed successfully';
                                } else {
                                    return `Error: ${r.error || 'Unknown error'}`;
                                }
                            }).join(', ');
                            
                            finalResponse += `\n\nüìã **Command Result:** ${resultSummary}`;
                            
                            if (result.functions.some(f => f.method === 'GET')) {
                                finalResponse += `\n‚ö†Ô∏è **Note:** Status inquiry executed but no data was returned from VehicleSim.`;
                            }
                        }
                    }

                    if (successfulCommands.length > 0) {
                        finalResponse += `\n\n‚úÖ **Actions Completed:**`;
                        successfulCommands.forEach(cmd => {
                            finalResponse += `\n‚Ä¢ ${cmd.status}`;
                        });
                    }
                } else if (!result.isVehicleCommand) {
                    messageClass = 'assistant knowledge';
                    finalResponse = `üß† **General Knowledge:** ${finalResponse}`;
                }

                addChatMessage(finalResponse, messageClass);
                speak(result.response);
            } catch (err) {
                console.error('Error:', err);
                showError('Failed to process command: ' + err.message);
            } finally {
                document.getElementById('send-button').disabled = false;
                setVoiceButtonState();
            }
        }

        async function processWithLLM(input, modelType, isVehicleQuery) {
            const baseSystemPrompt = isVehicleQuery ? vehicleSystemPrompt : generalSystemPrompt;
            const contextualSystemPrompt = buildContextualPrompt(input, baseSystemPrompt, isVehicleQuery);
            
            const fullPrompt = {
                system: contextualSystemPrompt,
                user: input,
                queryType: isVehicleQuery ? 'Vehicle Command' : 'General Knowledge',
                conversationLength: conversationHistory.length,
                contextActive: conversationHistory.length > 0
            };
            addPromptLog(fullPrompt, isVehicleQuery);

            let responseText;
            if (modelType === 'openai') {
                responseText = await callOpenAI(input, contextualSystemPrompt);
            } else if (modelType === 'claude') {
                responseText = await callClaude(input, contextualSystemPrompt);
            } else if (modelType === 'local') {
                responseText = await callLocalLLM(input, contextualSystemPrompt, config.local);
            }

            try {
                const parsed = JSON.parse(responseText);
                addOutputLog(parsed, isVehicleQuery);
                return parsed;
            } catch (e) {
                const jsonMatch = responseText.match(/\{[\s\S]*\}/);
                if (jsonMatch) {
                    const parsed = JSON.parse(jsonMatch[0]);
                    addOutputLog(parsed, isVehicleQuery);
                    return parsed;
                }
                return { response: responseText, isVehicleCommand: isVehicleQuery };
            }
        }

        async function callOpenAI(input, systemPrompt) {
            if (!config.openai.apiKey) {
                throw new Error('OpenAI API key not configured');
            }
            
            const res = await fetch(config.openai.endpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${config.openai.apiKey}`
                },
                body: JSON.stringify({
                    model: config.openai.model,
                    messages: [
                        { role: 'system', content: systemPrompt },
                        { role: 'user', content: input }
                    ],
                    temperature: 0.7,
                    max_tokens: 500
                })
            });
            
            if (!res.ok) {
                const error = await res.text();
                throw new Error('OpenAI API error: ' + error);
            }
            
            const data = await res.json();
            return data.choices[0].message.content;
        }

        async function callClaude(input, systemPrompt) {
            if (!config.claude.apiKey) {
                throw new Error('Claude API key not configured');
            }
            
            const res = await fetch(config.claude.endpoint, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'x-api-key': config.claude.apiKey,
                    'anthropic-version': '2023-06-01'
                },
                body: JSON.stringify({
                    model: config.claude.model,
                    max_tokens: 500,
                    messages: [
                        { role: 'user', content: `${systemPrompt}\n\nUser: ${input}` }
                    ]
                })
            });
            
            if (!res.ok) {
                const error = await res.text();
                throw new Error('Claude API error: ' + error);
            }
            
            const data = await res.json();
            return data.content[0].text;
        }

        async function callLocalLLM(input, systemPrompt, cfg) {
            if (!cfg.model) {
                throw new Error('Local LLM model not configured');
            }
            
            const res = await fetch(cfg.endpoint, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    model: cfg.model,
                    messages: [
                        { role: 'system', content: systemPrompt },
                        { role: 'user', content: input }
                    ],
                    temperature: 0.7,
                    max_tokens: 500
                })
            });
            
            if (!res.ok) {
                const error = await res.text();
                throw new Error(`Local LLM error (${cfg.model}): ${error}`);
            }
            
            const data = await res.json();
            return data.choices[0].message.content;
        }

        async function executeVehicleCommands(functions) {
            if (!vehicleSimWindow || vehicleSimWindow.closed) {
                vehicleSimWindow = window.open(VEHICLESIM_URL, 'VehicleSim', 'width=1400,height=900');
                await new Promise(resolve => setTimeout(resolve, 3000));
                await waitForVehicleSimConnection();
            }
            
            const results = [];
            for (const func of functions) {
                try {
                    console.log(`üöó Executing: ${func.method || 'POST'} ${func.endpoint}`, func.body || {});
                    
                    const messageId = Date.now() + Math.random();
                    vehicleSimWindow.postMessage({
                        type: 'KITT_COMMAND',
                        id: messageId,
                        endpoint: func.endpoint,
                        method: func.method || 'POST',
                        body: func.body || {}
                    }, VEHICLESIM_URL);

                    const result = await new Promise((resolve, reject) => {
                        const timeout = setTimeout(() => {
                            reject(new Error('Command timeout after 10 seconds'));
                        }, 10000);

                        const listener = (event) => {
                            if (event.origin !== new URL(VEHICLESIM_URL).origin) {
                                return;
                            }
                            
                            if (event.data && event.data.type === 'KITT_RESPONSE' && event.data.id === messageId) {
                                clearTimeout(timeout);
                                window.removeEventListener('message', listener);
                                updateVehicleSimStatus(true);
                                if (event.data.error) reject(new Error(event.data.error));
                                else resolve(event.data.result);
                            }
                        };
                        window.addEventListener('message', listener);
                    });

                    console.log(`‚úÖ Result from ${func.endpoint}:`, result);
                    results.push(result);
                } catch (error) {
                    console.error(`‚ùå Failed to execute command ${func.endpoint}:`, error);
                    results.push({ success: false, error: error.message });
                    
                    if (error.message.includes('timeout')) {
                        updateVehicleSimStatus(false);
                    }
                }
            }
            console.log('üîÑ All command results:', results);
            return results;
        }

        async function waitForVehicleSimConnection() {
            return new Promise((resolve) => {
                let attempts = 0;
                const maxAttempts = 10;
                
                const checkConnection = setInterval(() => {
                    attempts++;
                    console.log(`üîç Checking VehicleSim connection... (attempt ${attempts}/${maxAttempts})`);
                    
                    if (vehicleSimWindow && !vehicleSimWindow.closed) {
                        vehicleSimWindow.postMessage({
                            type: 'KITT_PING',
                            id: 'ping-' + Date.now()
                        }, VEHICLESIM_URL);
                    }
                    
                    if (vehicleSimConnected || attempts >= maxAttempts) {
                        clearInterval(checkConnection);
                        resolve();
                    }
                }, 1000);
            });
        }

        // UI Helper Functions
        function addChatMessage(message, type) {
            const chatContainer = document.getElementById('chat-container');
            const msgDiv = document.createElement('div');
            msgDiv.className = `chat-message ${type}-message`;
            msgDiv.innerHTML = message.replace(/\n/g, '<br>').replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
            chatContainer.appendChild(msgDiv);
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        function addSystemMessage(msg) {
            addChatMessage(msg, 'system');
        }

        function showError(msg) {
            addSystemMessage('Error: ' + msg);
            document.getElementById('status-dot').classList.add('error');
            document.getElementById('status-text').textContent = 'Error';
            setTimeout(() => {
                document.getElementById('status-dot').classList.remove('error');
                document.getElementById('status-text').textContent = 'Ready';
            }, 3000);
        }

        function addPromptLog(prompt, isVehicleQuery = false) {
            const logDiv = document.createElement('div');
            logDiv.className = `log-entry ${isVehicleQuery ? '' : 'knowledge'}`;
            
            // Sanitize the prompt to remove sensitive API keys
            const sanitizedPrompt = JSON.parse(JSON.stringify(prompt));
            if (sanitizedPrompt.system) {
                sanitizedPrompt.system = sanitizedPrompt.system.substring(0, 200) + '...';
            }
            
            logDiv.innerHTML = `<strong>${isVehicleQuery ? 'Vehicle' : 'Knowledge'} Prompt:</strong><br>${JSON.stringify(sanitizedPrompt, null, 2)}`;
            logDiv.onclick = () => showFullPrompt(prompt);
            document.getElementById('prompt-log').insertBefore(logDiv, document.getElementById('prompt-log').firstChild);
        }

        function addOutputLog(output, isVehicleQuery = false) {
            const logDiv = document.createElement('div');
            logDiv.className = `log-entry ${isVehicleQuery ? '' : 'knowledge'}`;
            logDiv.innerHTML = `<strong>${isVehicleQuery ? 'Vehicle' : 'Knowledge'} Output:</strong><br>${JSON.stringify(output, null, 2)}`;
            logDiv.onclick = () => showFullOutput(output);
            document.getElementById('output-log').insertBefore(logDiv, document.getElementById('output-log').firstChild);
        }

        function showFullPrompt(prompt) {
            document.getElementById('full-prompt-content').textContent = JSON.stringify(prompt, null, 2);
            document.getElementById('prompt-display').style.display = 'block';
        }

        function closePromptDisplay() {
            document.getElementById('prompt-display').style.display = 'none';
        }

        function showFullOutput(output) {
            document.getElementById('full-output-content').textContent = JSON.stringify(output, null, 2);
            document.getElementById('output-display').style.display = 'block';
        }

        function closeOutputDisplay() {
            document.getElementById('output-display').style.display = 'none';
        }

        // Listen for messages from VehicleSim
        window.addEventListener('message', (event) => {
            if (event.origin !== new URL(VEHICLESIM_URL).origin) {
                return;
            }
            
            if (event.data && event.data.type === 'KITT_PONG') {
                console.log('‚úÖ VehicleSim connection confirmed');
                updateVehicleSimStatus(true);
            }
        });

        // Initialize on load
        window.addEventListener('load', () => {
            // Load configuration
            if (loadConfig()) {
                addSystemMessage('‚úÖ Configuration loaded from local storage');
            } else {
                addSystemMessage('üîß No configuration found. Please configure API keys to get started.');
                showConfigModal();
            }
            
            // Load conversation memory
            if (PersistentConversationMemory.load()) {
                const memoryInfo = PersistentConversationMemory.getStorageInfo();
                addContextIndicator(`üíæ Loaded conversation memory: ${memoryInfo.messageCount} messages, last activity: ${memoryInfo.lastActivity}`);
            }
            
            if ('speechSynthesis' in window) {
                speechSynthesis.getVoices();
            }
            
            setTimeout(() => {
                addSystemMessage('‚úÖ KITTWeb v6 Ready!');
                addSystemMessage(`üåê VehicleSim deployed at: ${VEHICLESIM_URL}`);
                addSystemMessage('üöó **Vehicle Commands:** "Start the car", "Lock all doors", "It\'s too hot", "Navigate to office"');
                addSystemMessage('üìä **Status Inquiries:** "What\'s the engine status?", "Check climate", "Show door status"');
                addSystemMessage('üß† **General Knowledge:** "What\'s the capital of Japan?", "Explain quantum physics"');
                addSystemMessage('üíæ **Persistent Memory:** I remember our conversations across browser sessions!');
                addSystemMessage('üîê **Privacy:** Your API keys are stored locally in your browser only.');
            }, 1000);
        });

        document.getElementById('model-select').addEventListener('change', (e) => {
            currentModel = e.target.value;
            addSystemMessage(`Switched to ${e.target.options[e.target.selectedIndex].text}`);
        });

        document.getElementById('context-timeout').addEventListener('change', (e) => {
            const newTimeout = parseInt(e.target.value) || 5;
            contextTimeoutMinutes = newTimeout;
            addSystemMessage(`Context timeout set to ${newTimeout} minutes`);
            PersistentConversationMemory.save();
        });

        // Close modal when clicking outside
        document.getElementById('config-modal').addEventListener('click', (e) => {
            if (e.target === e.currentTarget) {
                hideConfigModal();
            }
        });
    </script>
</body>
</html>